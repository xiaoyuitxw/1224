<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>圣诞代码树</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at top, #071226 0%, #000 60%);
            font-family: Arial, sans-serif;
        }
        .info {
            position: absolute;
            top: 12px;
            left: 12px;
            color: #fff;
            background: rgba(0,0,0,0.25);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            user-select: none;
        }
    </style>
</head>
<body>
    <div class="info">Merry Christmas — 圣诞快乐</div>

    <script>
    // 基本设置：场景 / 相机 / 渲染器
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.02);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // 环境光与点光（用于星星发光）
    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.2);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    // 地面（非常简单的暗影参考面）
    const groundGeo = new THREE.PlaneGeometry(40, 40);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x050305, shininess: 0 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -2.6;
    scene.add(ground);

    // 生成树叶粒子（绿色渐变）
    const leafCount = 9000;
    const leafGeo = new THREE.BufferGeometry();
    const leafPos = new Float32Array(leafCount * 3);
    const leafColor = new Float32Array(leafCount * 3);

    // 树形参数：锥体（圆锥）分布
    const treeHeight = 5.5;
    const baseRadius = 2.6;
    const thetaLen = Math.PI * 2;

    for (let i = 0; i < leafCount; i++) {
        // v: 0..1 越接近1越在树顶部，u: 周向角
        const v = Math.pow(Math.random(), 0.9); // 稍微更多粒子集中在下部
        const u = Math.random() * thetaLen;
        // 基于高度计算半径（锥体）
        const localRadius = baseRadius * (1 - v) * (0.6 + 0.4 * Math.random());
        const y = -treeHeight/2 + v * treeHeight + (Math.random() - 0.5) * 0.08; // 加一点抖动
        const x = Math.cos(u) * localRadius;
        const z = Math.sin(u) * localRadius;

        leafPos[i*3] = x;
        leafPos[i*3 + 1] = y;
        leafPos[i*3 + 2] = z;

        // 绿色渐变：底部深绿，顶部亮绿 / 带点黄色暖色
        const t = v; // 0..1
        const r = 0.02 + 0.05 * t; // 几乎没有红
        const g = 0.35 + 0.55 * t; // 主绿
        const b = 0.05 + 0.15 * (1 - t);
        leafColor[i*3] = r;
        leafColor[i*3 + 1] = g;
        leafColor[i*3 + 2] = b;
    }

    leafGeo.setAttribute('position', new THREE.BufferAttribute(leafPos, 3));
    leafGeo.setAttribute('color', new THREE.BufferAttribute(leafColor, 3));

    const leafMat = new THREE.PointsMaterial({
        size: 0.06,
        vertexColors: true,
        transparent: true,
        opacity: 0.95,
        sizeAttenuation: true,
        depthWrite: false
    });

    const leaves = new THREE.Points(leafGeo, leafMat);
    scene.add(leaves);

    // 生成装饰灯（装饰球），数量少，颜色鲜艳并闪烁
    const ornamentCount = 220;
    const ornamentGeo = new THREE.BufferGeometry();
    const ornamentPos = new Float32Array(ornamentCount * 3);
    const ornamentColor = new Float32Array(ornamentCount * 3);
    const ornamentBaseBrightness = new Float32Array(ornamentCount); // 用于每个灯独立闪烁偏移

    const colorsPalette = [
        new THREE.Color(0xff2d55), // 红
        new THREE.Color(0xffd60a), // 黄
        new THREE.Color(0x1ad6ff), // 青
        new THREE.Color(0xff7ab6), // 粉
        new THREE.Color(0x7eff6b)  // 亮绿
    ];

    for (let i = 0; i < ornamentCount; i++) {
        // 放在与树叶相似的表面上，靠近树表面
        const v = Math.random() ** 0.9;
        const u = Math.random() * thetaLen;
        const r = baseRadius * (1 - v) * (0.75 + Math.random() * 0.25);
        const y = -treeHeight/2 + v * treeHeight;
        const x = Math.cos(u) * r + (Math.random()-0.5) * 0.03;
        const z = Math.sin(u) * r + (Math.random()-0.5) * 0.03;

        ornamentPos[i*3] = x;
        ornamentPos[i*3+1] = y;
        ornamentPos[i*3+2] = z;

        const col = colorsPalette[Math.floor(Math.random() * colorsPalette.length)];
        ornamentColor[i*3] = col.r;
        ornamentColor[i*3+1] = col.g;
        ornamentColor[i*3+2] = col.b;

        ornamentBaseBrightness[i] = Math.random() * Math.PI * 2;
    }

    ornamentGeo.setAttribute('position', new THREE.BufferAttribute(ornamentPos, 3));
    ornamentGeo.setAttribute('color', new THREE.BufferAttribute(ornamentColor, 3));
    ornamentGeo.setAttribute('aBrightness', new THREE.BufferAttribute(ornamentBaseBrightness, 1));

    const ornamentMat = new THREE.PointsMaterial({
        size: 0.14,
        vertexColors: true,
        transparent: true,
        opacity: 1.0,
        sizeAttenuation: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    const ornaments = new THREE.Points(ornamentGeo, ornamentMat);
    scene.add(ornaments);

    // 树顶的星星（发光的小球 + 简单的光源）
    const starGeo = new THREE.SphereGeometry(0.2, 16, 12);
    const starMat = new THREE.MeshBasicMaterial({ color: 0xfff1a8 });
    const star = new THREE.Mesh(starGeo, starMat);
    star.position.set(0, treeHeight/2 - 0.05, 0);
    scene.add(star);

    const starLight = new THREE.PointLight(0xfff1a8, 0.9, 6, 2);
    starLight.position.copy(star.position);
    scene.add(starLight);

    // 背景星点（远处小点）
    const skyCount = 600;
    const skyGeo = new THREE.BufferGeometry();
    const skyPos = new Float32Array(skyCount * 3);
    const skyCol = new Float32Array(skyCount * 3);
    for (let i = 0; i < skyCount; i++) {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        const d = 40 + Math.random() * 60;
        const x = Math.sin(phi) * Math.cos(theta) * d;
        const y = Math.sin(phi) * Math.sin(theta) * d * 0.6 + 6;
        const z = Math.cos(phi) * d;
        skyPos[i*3] = x;
        skyPos[i*3+1] = y;
        skyPos[i*3+2] = z;

        const v = 0.6 + Math.random() * 0.4;
        skyCol[i*3] = v;
        skyCol[i*3+1] = v;
        skyCol[i*3+2] = v;
    }
    skyGeo.setAttribute('position', new THREE.BufferAttribute(skyPos, 3));
    skyGeo.setAttribute('color', new THREE.BufferAttribute(skyCol, 3));
    const skyMat = new THREE.PointsMaterial({ size: 0.03, color: 0xffffff, vertexColors: true, transparent: true, opacity: 0.9 });
    const sky = new THREE.Points(skyGeo, skyMat);
    scene.add(sky);

    // Orbit 控制器
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.12;
    controls.minDistance = 3;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI * 0.48;

    // 动画变量
    const clock = new THREE.Clock();

    function animate() {
        const t = clock.getElapsedTime();

        // 轻微整体旋转 / 摆动
        leaves.rotation.y = Math.sin(t * 0.15) * 0.03;
        ornaments.rotation.y = Math.sin(t * 0.17) * 0.04;
        sky.rotation.y = t * 0.005;

        // 装饰灯闪烁（通过改变颜色亮度）
        const colAttr = ornamentGeo.getAttribute('color');
        const baseBrightnessAttr = ornamentGeo.getAttribute('aBrightness');
        for (let i = 0; i < ornamentCount; i++) {
            const offs = baseBrightnessAttr.getX(i);
            const flick = 0.6 + 0.4 * Math.abs(Math.sin(t * (0.8 + (i % 5) * 0.12) + offs));
            // 将原始颜色乘以 flick
            const r = colAttr.getX(i) * flick;
            const g = colAttr.getY(i) * flick;
            const b = colAttr.getZ(i) * flick;
            colAttr.setXYZ(i, r, g, b);
        }
        colAttr.needsUpdate = true;

        // 星星脉动
        const starScale = 1 + 0.12 * Math.sin(t * 3.2);
        star.scale.setScalar(starScale);
        starLight.intensity = 0.9 + 0.6 * Math.abs(Math.sin(t * 3.2));

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    animate();

    // 窗口调整
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    });

    </script>
</body>
</html>